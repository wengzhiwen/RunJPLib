# 推荐阅读算法实现说明

本文档详细介绍了 RunJPLib 项目中推荐阅读功能的时间权重算法实现和缓存机制。

## 1. 算法概述

推荐阅读功能使用时间权重算法，确保最新的博客文章有更高的展示权重，同时保持内容的多样性和避免重复推荐。为了提高性能，还实现了TTL缓存机制。

## 2. 算法逻辑

### 2.1 时间分组
算法首先将博客按时间分为三个组：
- **最近3天**: 最高权重组
- **最近7天**: 中等权重组  
- **更早**: 基础权重组

### 2.2 选择步骤

#### Step 1: 从最近3天的blog中选2条
- 目标：选择2条最近3天的博客
- 实现：使用 `random.sample()` 随机选择，但不超过可用数量
- 如果最近3天没有博客，跳过此步骤

#### Step 2: 从最近7天的blog中选不重复的补足3条
- 目标：从最近7天的博客中补足到总共3条
- 实现：
  - 计算还需要多少篇：`needed_from_7_days = 3 - len(selected_blogs)`
  - 从可选的7天博客中随机选择需要的数量
  - 确保不重复选择已选中的博客

#### Step 3: 从剩下的blog中选不重复的补足3条
- 目标：从剩余博客中补足到总共3条
- 实现：从所有未选择的博客中随机选择需要的数量
- 作为兜底机制，确保总能推荐到指定数量的文章

## 3. 缓存机制

### 3.1 缓存策略
- **缓存类型**: TTL缓存（Time To Live）
- **缓存时间**: 30分钟（1800秒）
- **缓存大小**: 最大1个条目
- **缓存目的**: 避免每次用户访问都重新执行推荐算法

### 3.2 缓存实现
```python
recommended_blogs_cache = TTLCache(maxsize=1, ttl=1800)

@cached(recommended_blogs_cache)
def get_weighted_recommended_blogs_with_summary(count=3):
    # 推荐算法实现
```

### 3.3 缓存清除
- **自动清除**: 在博客创建或更新时自动清除缓存
- **手动清除**: 提供 `clear_recommended_blogs_cache()` 函数
- **清除时机**: 确保新内容能及时出现在推荐中

## 4. 技术实现

### 4.1 核心函数
```python
def get_weighted_recommended_blogs_with_summary(count=3):
    """
    根据时间权重算法获取推荐博客，并生成摘要。
    """
```

### 4.2 关键特性
- **日期比较优化**: 使用 `.date()` 方法只比较日期部分，忽略时间部分
- **去重机制**: 使用 `used_url_titles` 集合避免重复推荐
- **容错处理**: 如果某个步骤失败，自动回退到随机推荐算法
- **详细日志**: 提供完整的debug日志，便于跟踪算法执行过程
- **缓存机制**: 使用TTL缓存提升性能，减少数据库查询

### 4.3 数据结构
```python
# 博客对象结构
{
    'title': '博客标题',
    'url_title': 'URL友好的标题',
    'content_md': 'markdown内容',
    'publication_date': '发布日期'
}

# 推荐结果结构
{
    'title': '博客标题',
    'url_title': 'URL友好的标题', 
    'summary': '生成的摘要'
}
```

## 5. 性能优化

### 5.1 缓存效果
- **响应时间**: 从每次执行算法变为直接返回缓存结果
- **数据库负载**: 减少对MongoDB的频繁查询
- **用户体验**: 页面加载速度显著提升

### 5.2 缓存策略优势
- **平衡性**: 30分钟TTL平衡了性能提升和内容新鲜度
- **智能性**: 博客更新时自动清除缓存
- **可靠性**: 缓存失效时自动回退到算法执行

## 6. 测试验证

### 6.1 测试工具
- `tools/test_recommendation_cache.py`: 缓存机制测试
- `tools/test_recommendation_algorithm.py`: 算法逻辑测试

### 6.2 测试内容
- 缓存命中率验证
- 缓存清除功能测试
- 算法执行时间对比
- 推荐结果一致性检查
