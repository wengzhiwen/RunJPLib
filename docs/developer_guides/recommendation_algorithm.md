# 推荐阅读算法

为了在博客和首页向用户展示相关且及时的内容，RunJPLib 实现了一套带时间权重的推荐算法，并结合了缓存机制以优化性能。

## 算法逻辑

核心目标是让最新的博客文章有更高的曝光率，同时保证推荐内容的多样性。

### 1. 时间分组
算法首先将所有博客文章按发布日期分为三组：
- **最近3天**: 最高权重组。
- **最近7天**: 中等权重组。
- **更早**: 基础权重组。

### 2. 选择步骤 (以推荐3篇为例)
1.  **优先选择最新**: 从“最近3天”的博客中，随机选择 **2** 篇。
2.  **智能补足**: 如果上一步选不满，则从“最近7天”的博客中选择不重复的文章，补足 **3** 篇。
3.  **兜底选择**: 如果前两步加起来仍不足3篇，则从“更早”的博客中随机选择，直到总数达到3篇。

这种机制确保了只要有新文章，它们就极有可能被推荐，同时也通过随机选择保证了一定的多样性。

## 性能优化：TTL 缓存

由于推荐算法需要查询和处理数据库，为了避免在每次页面加载时都重复计算，我们引入了缓存机制。

- **缓存策略**: 使用 `cachetools.TTLCache` 实现了一个有效期为 **30分钟** 的内存缓存。
- **工作流程**: 当一个请求需要推荐内容时，系统会首先检查缓存。如果缓存中有未过期的结果，则直接返回；否则，执行完整的算法逻辑，并将结果存入缓存，供后续请求使用。
- **缓存自动失效**: 为了保证内容的新鲜度，当管理员在后台**创建或更新**任何博客文章时，推荐缓存会被**自动清除**。这确保了新的或更新的文章能够立即出现在推荐列表中。

## 技术实现

- **核心函数**: `routes.blog.py` 中的 `get_weighted_recommended_blogs_with_summary()`。
- **缓存实现**: 使用 `@cached(recommended_blogs_cache)` 装饰器应用缓存。
- **摘要生成**: 在生成推荐列表时，会使用 `markdown` 库将文章的 Markdown 内容转换为纯文本摘要，避免在推荐卡片中显示原始的 Markdown 标签。
